<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java 21 OCP Free Mock Exam | Practice OCP 21 Questions Online</title>
    <meta name="description" content="Take a free Java 21 OCP mock exam online. Practice OCP 21 questions with answers, explanations, and test your Java certification readiness.">
	<meta property="og:title" content="Java 21 OCP Free Mock Exam" />
    <meta property="og:description" content="Practice OCP 21 questions with explanations online." />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://anasss.github.io/java21docCards/java21-quiz.html" />
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .quiz-container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .quiz-header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .quiz-header h1 {
            margin: 0;
            font-size: 2.2em;
            font-weight: 300;
        }
        
        .quiz-header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .quiz-body {
            padding: 30px;
        }
        
        .question {
            display: none;
            margin-bottom: 30px;
            animation: fadeIn 0.5s ease-in;
        }
        
        .question.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        
        .question-number {
            font-weight: bold;
            color: #667eea;
            font-size: 1.1em;
        }
        
        .question-text {
            font-size: 1.15em;
            margin-bottom: 25px;
            color: #2c3e50;
            line-height: 1.8;
        }
        
        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow-x: auto;
            border: 1px solid #333;
            white-space: pre;
        }
        
        .options {
            display: grid;
            gap: 12px;
            margin-top: 25px;
        }
        
        .option {
            padding: 15px 20px;
            border: 2px solid #e1e8ed;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            position: relative;
        }
        
        .option:hover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: translateX(5px);
        }
        
        .option.selected {
            border-color: #667eea;
            background: #e8f0ff;
        }
        
        .option.correct {
            border-color: #27ae60;
            background: #d5f4e6;
            color: #27ae60;
        }
        
        .option.incorrect {
            border-color: #e74c3c;
            background: #fdeaea;
            color: #e74c3c;
        }
        
        .option-label {
            font-weight: bold;
            margin-right: 10px;
            color: #667eea;
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            padding: 20px 0;
            border-top: 1px solid #eee;
        }
        
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #545b62;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e1e8ed;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .score-display {
            text-align: center;
            font-size: 1.2em;
            color: #667eea;
            font-weight: bold;
        }
        
        .explanation {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-left: 4px solid #17a2b8;
            border-radius: 5px;
            display: none;
        }
        
        .explanation.show {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }
        
        .explanation h4 {
            margin: 0 0 10px 0;
            color: #17a2b8;
        }
        
        .results {
            display: none;
            text-align: center;
            padding: 40px 20px;
        }
        
        .results.show {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }
        
        .results h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 2.5em;
        }
        
        .final-score {
            font-size: 3em;
            font-weight: bold;
            margin: 20px 0;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .score-message {
            font-size: 1.3em;
            color: #6c757d;
            margin-bottom: 30px;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .quiz-body {
                padding: 20px;
            }
            
            .controls {
                flex-direction: column;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="quiz-container">
        <div class="quiz-header">
            <h1>Java 21 OCP Quiz</h1>
            <p>Test your knowledge of Java 21 OCP exam topics</p>
        </div>
        
        <div class="quiz-body">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            
            <div class="score-display">
                <span id="currentQuestion">1</span> / <span id="totalQuestions">10</span> | 
                Score: <span id="currentScore">0</span> / <span id="maxScore">10</span>
            </div>
            
            <div id="questionContainer">
                <!-- Questions will be inserted here -->
            </div>
            
            <div class="controls">
                <button class="btn btn-secondary" id="prevBtn" onclick="previousQuestion()" disabled>Previous</button>
				<button class="btn btn-primary" onclick="window.location.href='/java21docCards/'">
					Back to Flashcards </button>
                <button class="btn btn-primary" id="nextBtn" onclick="nextQuestion()" disabled>Next Question</button>
            </div>
            
            <div class="results" id="results">
                <h2>Quiz Complete!</h2>
                <div class="final-score" id="finalScore">0/10</div>
                <div class="score-message" id="scoreMessage">Great job!</div>
                <button class="btn btn-primary" onclick="restartQuiz()">Restart Quiz</button>
				<button class="btn btn-primary" onclick="window.location.href='/java21docCards/'">
					Study Flashcards </button>
            </div>
        </div>
    </div>

    <script>
        // Define questions as simple objects
var questions = [
  {
    question: "Which method calls will execute in this inheritance scenario?",
    code: "class Parent {\n    public void show() { System.out.print(\"Parent \"); }\n}\nclass Child extends Parent {\n    public void show() { System.out.print(\"Child \"); }\n    public static void main(String[] args) {\n        Parent dad = new Child();\n        dad.show();\n        new Child().show();\n        new Parent().show();\n    }\n}",
    options: ["Parent Parent Parent", "Child Child Parent", "Child Parent Child", "Parent Child Parent"],
    correct: 1,
    explanation: "Overridden methods in subclasses are executed according to the runtime type of the object."
  },
  {
	question: "What is the output of this family membership code?",
	code: "var isMother = false;\n" +
		"var isFather = false;\n" +
		"if (isFather = isMother != isFather) {\n" +
		"    System.out.println(\"You are part of the family!\");\n" +
		"} else {\n" +
		"    System.out.println(\"You are not part of the family!\");\n" +
		"}",
	options: [
		"You are part of the family!",
		"You are not part of the family!",
		"Compilation error",
		"Runtime exception",
		"Unreachable code error"
	],
	correct: 1,
	explanation: "The expression 'isFather = isMother != isFather' is evaluated as 'isFather = (isMother != isFather)'. Since isMother is false and isFather is false, (false != false) evaluates to false. However, this false value is then assigned to isFather, and the assignment expression returns the assigned value (false). The if condition gets false, so it goes to else and prints 'You are not part of the family!'."
  },
  {
    question: "Which statement about record classes is correct?",
    options: ["Records are mutable by default", "Records cannot define methods", "Record fields are final by default", "Records can extend other classes"],
    correct: 2,
    explanation: "Records are implicitly final and their fields are final. They can have methods but cannot extend other classes."
  },
  {
    question: "How are static and instance initialization blocks executed in this inheritance scenario?",
    code: "class Parent {\n    static { System.out.print(\"Parent static \" ); }\n    { System.out.print(\"Parent instance \" ); }\n}\nclass Child extends Parent {\n    static { System.out.print(\"Child static \" ); }\n    { System.out.print(\"Child instance \" ); }\n    public static void main(String[] args) { new Child(); }\n}",
    options: ["Parent static Child static Child instance Parent instance", "Parent static Child static Parent instance Child instance", "Child static Parent static Child instance Parent instance", "Parent instance Child instance Parent static Child static"],
    correct: 1,
    explanation: "Static blocks execute first (parent then child), followed by instance blocks (parent then child)."
  },
  {
    question: "Which sealed class declaration is valid?",
    options: ["public sealed class Family permit Unknown { }", "public sealed class Family permits Child { }", "public sealed class Family extends Object { }", "public sealed class Family { } // subclasses are in a different package"],
    correct: 1,
    explanation: "A sealed class must list its permitted subclasses. Only the second option is valid."
  },
  {
    question: "Which value does this switch expression evaluate to?",
    code: "String role = switch (\"Grandma\") {\n    case \"Dad\", \"Father\" -> \"Parent\";\n    case \"Mom\", \"Mother\" -> \"Parent\";\n    case \"Son\", \"Daughter\" -> \"Child\";\n    case \"Grandpa\", \"Grandma\" -> { yield \"Grandparent\".toUpperCase(); }\n    default -> \"Unknown\";\n};\nSystem.out.println(role);",
    options: ["Parent", "Unknown", "Grandparent", "GRANDPARENT"],
    correct: 3,
    explanation: "Yield block returns \"Grandparent\" converted to uppercase."
  },
  {
    question: "Which private method is invoked in this inheritance scenario?",
    code: "class Parent {\n    private void secret() { System.out.print(\"Parent secret \" ); }\n    public void reveal() { secret(); }\n}\nclass Child extends Parent {\n    private void secret() { System.out.print(\"Child secret \" ); }\n    public static void main(String[] args) {\n        new Parent().reveal();\n    }\n}",
    options: ["Compilation error", "Parent secret Child secret", "Child secret", "Parent secret"],
    correct: 3,
    explanation: "Private methods are not overridden. Parent.reveal() calls Parent.secret()."
  },
  {
    question: "Which strings are selected after mapping and sorting this stream?",
    code: "import java.util.*;\nimport java.util.stream.*;\nclass Family {\n  public static void main(String[] args) {\n    var members = List.of(\"Dad\",\"Mom\",\"Son\",\"Daughter\");\n    var result = members.stream()\n      .map(String::toUpperCase)\n      .sorted((a,b) -> b.compareTo(a))\n      .limit(2)\n      .collect(Collectors.joining(\", \"));\n    System.out.println(result);\n  }\n}",
    options: ["SON, MOM", "DAD, MOM", "SON, DAUGHTER", "DAD, DAUGHTER"],
    correct: 0,
    explanation: "After mapping to uppercase and sorting descending, the first two elements are SON and MOM."
  },
  {
    question: "Is this override declaration valid considering checked exceptions?",
    code: "class Parent {\n  void cook() throws Exception { throw new Exception(\"Parent\"); }\n}\nclass Child extends Parent {\n  @Override void cook() throws java.io.IOException { throw new java.io.IOException(\"Child\"); }\n  public static void main(String[] args) throws Exception {\n    new Child().cook();\n  }\n}",
    options: ["Compilation error: must catch IOException", "Compiles and prints Child", "Prints Parent", "Compilation error: IOException not allowed"],
    correct: 1,
    explanation: "Child's cook() throws IOException, which is allowed as it is a subclass of Exception."
  },
  {
	question: "Which output results from these generic method calls?",
	code: "import java.util.*;\n" +
		"class Family&lt;T&gt; {\n" +
		"    public static &lt;U&gt; List&lt;U&gt; create(U a, U b) {\n" +
		"        return List.of(a, b);\n" +
		"    }\n\n" +
		"    public static void main(String[] args) {\n" +
		"        var parents = create(\"Dad\", \"Mom\");\n" +
		"        var ages = create(45, 42);\n" +
		"        System.out.println(parents.get(0) + \" \" + ages.get(1));\n" +
		"    }\n" +
		"}",
	options: ["Dad Mom", "Dad 42", "Compilation error", "Mom 45"],
	correct: 1,
	explanation: "Generic method infers types separately. Output: Dad 42."
  },
  {
	question: "Which instanceof check evaluates to true?",
	code: "sealed class Parent permits Child {}\n" +
	"final class Child extends Parent {}\n" +
	"class Family {\n" +
	"    public static void main(String[] args) {\n" +
	"        Parent p = new Child();\n" +
	"        System.out.println(p instanceof Parent); // line 1\n" +
	"        System.out.println(p instanceof Child);  // line 2\n" +
	"        System.out.println(p instanceof String); // line 3\n" +
	"        System.out.println(p instanceof Object); // line 4\n" +
	"    }\n" +
	"}",
	options: [
	"line 1 and 2",
	"line 3 and 4",
	"line 1, 2 and 4",
	"line 2",
	"line 1" ],
	correct: 2,
	explanation: "Since p references a Child object, both 'p instanceof Parent' and 'p instanceof Child' evaluate to true. 'Parent' is the superclass, and 'Child' is the actual object type. 'p instanceof Object' is always true."
  },
  {
    question: "What does the following code return?",
    code: "import java.util.*;\nclass Family {\n  public static void main(String[] args){\n    Optional<String> dad = Optional.ofNullable(null);\n    System.out.println(dad.orElse(\"Unknown\"));\n  }\n}",
    options: ["Compilation error", "Unknown", "Throws NullPointerException", "null"],
    correct: 1,
    explanation: "ofNullable(null) creates empty Optional. orElse supplies fallback."
  },
  {
	question: "How many characters are in this text block?",
	code: "class Family {\n" +
	"    public static void main(String[] args) {\n" +
	"        String s = \"\"\"\n" +
	"Dad\n" +
	"Mom\n" +
	"\"\"\";\n" +
	"        System.out.println(s.length());\n" +
	"    }\n" +
	"}",
	options: ["7", "8", "9", "10"],
	correct: 1,
	explanation: "Text block includes a trailing newline. 'Dad\\nMom\\n' → length 8."
  },
  {
	question: "Which branch executes in this pattern matching switch?",
	code: "class Family {\n" +
	"    static void who(Object o) {\n" +
	"        switch(o) {\n" +
	"            case String s -> System.out.println(\"String: \" + s);\n" +
	"            case Integer i -> System.out.println(\"Int: \" + i);\n" +
	"            default -> System.out.println(\"Other\");\n" +
	"        }\n" +
	"    }\n" +
	"    public static void main(String[] args) {\n" +
	"        who(\"Dad\");\n" +
	"    }\n" +
	"}",
	options: ["Compilation error", "Other", "Int: Dad", "String: Dad"],
	correct: 3,
	explanation: "Pattern matching for switch matches the String branch."
  },
  {
	question: "Europe/Paris moves clocks forward 1 hour for spring DST on 30 March 2025 (The clock jumps from 02:00 AM to 03:00 AM). What is the Duration in hours when adding 3 hours to 01:30 across this transition?",
	code: "import java.time.*;\n" +
	"class Family {\n" +
	"    public static void main(String[] args) {\n" +
	"        ZonedDateTime z1 = ZonedDateTime.of(2025, 3, 30, 1, 30, 0, 0, ZoneId.of(\"Europe/Paris\"));\n" +
	"        ZonedDateTime z2 = z1.plusHours(3);\n" +
	"        Duration d = Duration.between(z1, z2);\n" +
	"        System.out.println(d.toHours());\n" +
	"    }\n" +
	"}",
	options: ["2", "3", "-2", "-3", "Throws exception"],
	correct: 0,
	explanation: "On 30 March 2025, Europe/Paris starts Daylight Saving Time at 02:00 AM. The clock jumps forward to 03:00 AM, effectively skipping one hour. Starting at 01:30, adding 3 hours would normally reach 04:30 on the clock, but because 02:00–03:00 does not exist, only 2 actual hours pass. Duration.between measures actual elapsed time, so it returns 2 hours."
  },
  {
	question: "Which key does firstKey() return for a TreeMap with these entries?",
	code: "import java.util.*;\n" +
	"class Family {\n" +
	"    public static void main(String[] args) {\n" +
	"        var map = new TreeMap<String,Integer>();\n" +
	"        map.put(\"Mom\", 1);\n" +
	"        map.put(\"Dad\", 2);\n" +
	"        map.put(\"Son\", 3);\n" +
	"        System.out.println(map.firstKey());\n" +
	"    }\n" +
	"}",
	options: ["Son", "Dad", "null", "Mom"],
	correct: 1,
	explanation: "TreeMap orders keys naturally. firstKey() returns the smallest key: Dad."
  },
  {
	question: "Which order of constructor execution occurs in this inheritance example?",
	code: "class Parent {\n" +
	"    Parent() { System.out.print(\"P \"); }\n" +
	"}\n" +
	"class Child extends Parent {\n" +
	"    Child() { System.out.print(\"C \"); }\n" +
	"}\n" +
	"class Family {\n" +
	"    public static void main(String[] args) {\n" +
	"        new Child();\n" +
	"    }\n" +
	"}",
	options: ["C P", "P C", "C only", "Compilation error"],
	correct: 1,
	explanation: "Superclass constructor runs before subclass constructor."
  },
  {
	question: "Which elements are processed by dropWhile in this stream?",
	code: "import java.util.*;\n" +
	"class Family {\n" +
	"    public static void main(String[] args) {\n" +
	"        List<String> list = List.of(\"Dad\",\"Mom\",\"Son\");\n" +
	"        list.stream().dropWhile(s -> s.length() > 2).forEach(System.out::print);\n" +
	"    }\n" +
	"}",
	options: ["Son", "", "MomSon", "DadMomSon"],
	correct: 2,
	explanation: "dropWhile removes elements from the start while the predicate is true. Prints MomSon."
  },
  {
	question: "Which value is returned by Arrays.binarySearch when the key is absent?",
	code: "class Family {\n" +
	"    public static void main(String[] args) {\n" +
	"        int[] arr = {10,20,30};\n" +
	"        int pos = java.util.Arrays.binarySearch(arr,25);\n" +
	"        System.out.println(pos);\n" +
	"    }\n" +
	"}",
	options: ["2", "-3", "-2", "Compilation error"],
	correct: 1,
	explanation: "Not found → returns -(insertion point) - 1. 25 would be at index 2 → -(2)-1 = -3."
  },
  {
	question: "What is the effect of reassignment inside a method on a StringBuilder?",
	code: "class Family {\n" +
	"    static void test(StringBuilder sb) {\n" +
	"        sb.append(\"Mom\");\n" +
	"        sb = new StringBuilder(\"Dad\");\n" +
	"    }\n" +
	"    public static void main(String[] args) {\n" +
	"        StringBuilder s = new StringBuilder(\"Son\");\n" +
	"        test(s);\n" +
	"        System.out.println(s);\n" +
	"    }\n" +
	"}",
	options: ["Son", "SonMom", "Dad", "Compilation error"],
	correct: 1,
	explanation: "Append modifies the original. Reassignment inside the method has no effect on the caller."
  },
  {
	question: "How does equals behave with StringBuilder references?",
	code: "class Family {\n" +
	"    public static void main(String[] args) {\n" +
	"        Object o = new StringBuilder(\"Dad\");\n" +
	"        System.out.println(o.equals(new StringBuilder(\"Dad\")));\n" +
	"    }\n" +
	"}",
	options: ["true", "false", "Compilation error", "Throws exception"],
	correct: 1,
	explanation: "StringBuilder does not override equals. Uses reference equality."
  },
  {
	question: "Consider a try-with-resources block that uses an AutoCloseable resource and also has a finally block. Which output is correct?",
	code: "class Resource implements AutoCloseable {\n" +
		"    public void use() { System.out.print(\"Using\"); }\n" +
		"    public void close() { System.out.print(\"Closed\"); }\n" +
		"}\n" +
		"class Family {\n" +
		"    public static void main(String[] args) {\n" +
		"        Resource r = new Resource();\n" +
		"        try (r) {\n" +
		"            r.use();\n" +
		"        } finally {\n" +
		"            System.out.print(\"Finally\");\n" +
		"        }\n" +
		"    }\n" +
		"}",
	options: [
	"UsingFinallyClosed",
	"FinallyUsingClosed",
	"UsingClosedFinally",
	"UsingClosed",
	"FinallyClosedUsing"
	],
	correct: 2,
	explanation: "Even when the resource is declared outside the try (Java 9+ feature), try-with-resources still calls close() after the try block completes. Then the finally block executes. So the output order is 'Using' (try body) → 'Closed' (resource auto-close) → 'Finally' (finally block)."
  },
  {
	question: "Given the following family hierarchy and variable declarations, which statements compile without error?",
	code: "import java.util.*;\n" +
		"class Grandparent {}\n" +
		"class Parent extends Grandparent {}\n" +
		"class Child extends Parent {}\n" +
		"class Family {\n" +
		"    List&lt;? super Grandparent&gt; ancestors = null;\n" +
		"    List&lt;? extends Child&gt; descendants = null;\n" +
		"}",
	options: [
		"ancestors.add(new Grandparent()); ancestors.add(new Parent()); ancestors.add(new Child());",
		"descendants.add(new Child()); descendants.add(new Parent());",
		"Grandparent g = ancestors.get(0);",
		"Parent p = ancestors.get(0);",
		"Child c = descendants.get(0);"
	],
	correct: 0,
	explanation: "For List&lt;? super Grandparent&gt; you can add Grandparent or any subclass. For List&lt;? extends Child&gt; you cannot add anything except null. The return type of get() cannot be assumed without casting, so assignments to specific types other than Object are compilation errors. Option 0 compiles fully; the others do not."
  },
  {
	question: "Which sequence prints in a for-loop with initialization side-effect?",
	code: "class Family {\n" +
	"    public static void main(String[] args) {\n" +
	"        int i = 0;\n" +
	"        for(System.out.print(\"Dad\"); i < 2; i++) {\n" +
	"            System.out.print(\"Son\");\n" +
	"        }\n" +
	"    }\n" +
	"}",
	options: ["DadSon", "DadSonSon", "SonDadSon", "Compilation error"],
	correct: 1,
	explanation: "Init prints Dad once. Loop runs twice printing Son Son."
  },
  {
	question: "Which instanceof check returns false for a null reference?",
	code: "class Family {\n" +
	"    public static void main(String[] args) {\n" +
	"        String s = null;\n" +
	"        System.out.println(s instanceof String);\n" +
	"    }\n" +
	"}",
	options: ["true", "false", "Compilation error", "Throws exception"],
	correct: 1,
	explanation: "instanceof returns false when the reference is null."
  },
  {
	question: "Inside a static method in Java 21, which of the following can be used to access an instance field?",
	code: "class Family {\n" +
		"    private String role = \"Parent\";\n" +
		"    static void test() {\n" +
		"        // ???\n" +
		"    }\n" +
		"}",
	options: [
	"Cannot access instance fields directly",
	"Access via creating an instance: new Family().role",
	"Access via 'this.role'",
	"Access via static import"
	],
	correct: 1,
	explanation: "Static methods cannot access instance fields directly. To access an instance field, you need a reference to an object, e.g., 'new Family().role'. 'this' cannot be used in a static context, and static import does not help."
},
  {
	question: "Which expression correctly handles a TreeMap key search?",
	code: "import java.util.*;\n" +
	"class Family {\n" +
	"    public static void main(String[] args) {\n" +
	"        var map = new TreeMap<String,Integer>();\n" +
	"        map.put(\"Dad\", 1);\n" +
	"        map.put(\"Mom\", 2);\n" +
	"        map.put(\"Son\", 3);\n" +
	"        /* ??? */\n" +
	"    }\n" +
	"}",
	options: ["map.firstKey()", "map.getKey(0)", "map.firstEntryKey()", "map.head()"],
	correct: 0,
	explanation: "TreeMap.firstKey() returns the least key according to natural order."
  },
  {
	question: "In a bottom-up migration to the Java module system, what is the recommended first step?",
	options: [
	"Move all existing JARs to the module path",
	"Convert all JARs to automatic modules at once",
	"Start by converting the module with the most dependencies",
	"Add a module-info.class to every JAR before running the application",
	"Start by converting the module with the fewest dependencies into a named module"
	],
	correct: 4,
	explanation: "In bottom-up migration, you begin by converting the module with the fewest dependencies into a named module. Other JARs stay on the classpath initially. This avoids breaking the build and allows gradual migration."
  },
  {
	question: "Which substring is extracted from this short text block?",
	code: "public class Family {\n" +
		"    public static void main(String[] args) {\n" +
		"        String familyMessage = \"\"\"\n" +
		"Hello! \n" +
		"Son\n" +
		"\"\"\";\n" +
		"        String part = familyMessage.substring(7, 9);\n" +
		"        System.out.println(part);\n" +
		"    }\n" +
		"}",
	options: ["So", "on", "\n S", "Son"],
	correct: 0,
	explanation: "The text block contains 'Hello! \\nSon'. Substring(7, 9) extracts characters at indexes 7 and 8: 'S' + 'o' = 'So'."
  },
  {
	question: "What is the output of this ExecutorService code?",
	code: "import java.util.concurrent.*;\n" +
		"public class Test {\n" +
		"    public static void main(String[] args) throws Exception {\n" +
		"        ExecutorService service = Executors.newFixedThreadPool(1);\n" +
		"        Runnable r = () -&gt; System.out.print(\"Runnable executed\");\n" +
		"        Callable&lt;String&gt; c = () -&gt; \"Callable executed\";\n" +
		"\n" +
		"        Future&lt;?&gt; f1 = service.submit(r);\n" +
		"        Future&lt;String&gt; f2 = service.submit(c);\n" +
		"\n" +
		"        System.out.print(f1.get());\n" +
		"        System.out.print(f2.get());\n" +
		"        service.shutdown();\n" +
		"    }\n" +
		"}",
	options: [
		"Runnable executedCallable executed",
		"Runnable executednullCallable executed",
		"nullCallable executed", 
		"Compilation error",
		"Runtime exception"
	],
	correct: 1,
	explanation: "submit(Runnable) returns a Future&lt;?&gt; whose get() returns null upon successful completion. submit(Callable&lt;T&gt;) returns a Future&lt;T&gt; whose get() returns the callable result. The output is: 'Runnable executed' (from the Runnable), then 'null' (from f1.get()), then 'Callable executed' (from f2.get()) - all printed consecutively without newlines since print() is used."
  }
];

var currentQuestionIndex = 0;
    var score = 0;
    var selectedAnswer = null;
    var answered = false;

    // Track per-question scoring and selected answers
    var scoredMap = new Array(questions.length).fill(false);
    var selectedAnswers = new Array(questions.length).fill(null);

    function initQuiz() {
        document.getElementById('totalQuestions').textContent = questions.length;
        document.getElementById('maxScore').textContent = questions.length;
        updateScore();
        displayQuestion();
    }

    function displayQuestion() {
        var container = document.getElementById('questionContainer');
        var question = questions[currentQuestionIndex];
        
        var html = '<div class="question active">';
        html += '<div class="question-header">';
        html += '<span class="question-number">Question ' + (currentQuestionIndex + 1) + '</span>';
        html += '</div>';
        html += '<div class="question-text">' + question.question + '</div>';
        
        if (question.code) {
            html += '<div class="code-block">' + question.code + '</div>';
        }
        
        html += '<div class="options" id="options">';
        for (var i = 0; i < question.options.length; i++) {
            html += '<div class="option" onclick="selectOption(' + i + ')">';
            html += '<span class="option-label">' + String.fromCharCode(65 + i) + '.</span>';
            html += question.options[i];
            html += '</div>';
        }
        html += '</div>';
        
        html += '<div class="explanation" id="explanation">';
        html += '<h4>Explanation:</h4>';
        html += '<p>' + question.explanation + '</p>';
        html += '</div>';
        html += '</div>';
        
        container.innerHTML = html;
        
        updateProgress();
        updateControls();

        // Restore previously selected answer if exists
        if (selectedAnswers[currentQuestionIndex] !== null) {
            selectOption(selectedAnswers[currentQuestionIndex], true);
        } else {
            selectedAnswer = null;
            answered = false;
            document.getElementById('nextBtn').disabled = true;
            document.getElementById('nextBtn').textContent = "Next Question";
        }
    }

    function selectOption(index, restoring = false) {
        if (answered && !restoring) return;

        var options = document.querySelectorAll('.option');
        for (var i = 0; i < options.length; i++) {
            options[i].classList.remove('selected', 'correct', 'incorrect');
        }
        options[index].classList.add('selected');
        
        selectedAnswer = index;
        selectedAnswers[currentQuestionIndex] = index;

        var question = questions[currentQuestionIndex];

        // Mark correct/incorrect
        for (var i = 0; i < options.length; i++) {
            if (i === question.correct) {
                options[i].classList.add('correct');
            } else if (i === selectedAnswer && i !== question.correct) {
                options[i].classList.add('incorrect');
            }
        }

        // Show explanation
        document.getElementById('explanation').classList.add('show');

        // Score only once per question
        if (!scoredMap[currentQuestionIndex] && selectedAnswer === question.correct) {
            score++;
            scoredMap[currentQuestionIndex] = true;
            updateScore();
        }

        answered = true;

        document.getElementById('nextBtn').disabled = false;
        document.getElementById('nextBtn').textContent = 
            currentQuestionIndex === questions.length - 1 ? 'Finish Quiz' : 'Next Question';
    }

    function nextQuestion() {
        if (!answered) return;

        if (currentQuestionIndex < questions.length - 1) {
            currentQuestionIndex++;
            displayQuestion();
        } else {
            showResults();
        }
    }

    function previousQuestion() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            displayQuestion();
        }
    }

    function updateProgress() {
        var progress = ((currentQuestionIndex) / questions.length) * 100;
        document.getElementById('progressFill').style.width = progress + '%';
        document.getElementById('currentQuestion').textContent = currentQuestionIndex + 1;
    }

    function updateControls() {
        document.getElementById('prevBtn').disabled = currentQuestionIndex === 0;
    }

    function updateScore() {
        document.getElementById('currentScore').textContent = score;
    }

    function showResults() {
        document.getElementById('questionContainer').style.display = 'none';
        document.querySelector('.controls').style.display = 'none';
        document.getElementById('results').classList.add('show');
        
        var percentage = Math.round((score / questions.length) * 100);
        document.getElementById('finalScore').textContent = score + '/' + questions.length;
        
        var message = '';
        if (percentage >= 90) {
            message = 'Excellent! You\'re ready for the OCP exam!';
        } else if (percentage >= 75) {
            message = 'Good job! Review the topics you missed and you\'ll be ready!';
        } else if (percentage >= 60) {
            message = 'Not bad! Study more and practice additional questions.';
        } else {
            message = 'Keep studying! Focus on the fundamentals and try again.';
        }
        
        document.getElementById('scoreMessage').textContent = message;
    }

    function restartQuiz() {
        currentQuestionIndex = 0;
        score = 0;
        selectedAnswer = null;
        answered = false;
        scoredMap = new Array(questions.length).fill(false);
        selectedAnswers = new Array(questions.length).fill(null);
        
        document.getElementById('results').classList.remove('show');
        document.getElementById('questionContainer').style.display = 'block';
        document.querySelector('.controls').style.display = 'flex';
        
        updateScore();
        displayQuestion();
    }

    document.addEventListener('DOMContentLoaded', initQuiz);
</script>
</body>
</html>