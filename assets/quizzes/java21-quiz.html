<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Java 21 OCP Practice Quiz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 2rem;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .quiz-container {
            padding: 2rem;
        }

        .question-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border-left: 4px solid #3498db;
            display: none;
        }

        .question-card.active {
            display: block;
            animation: slideIn 0.3s ease-in-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            color: #666;
            font-size: 0.9rem;
        }

        .question-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 1.5rem;
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 1rem;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            margin: 1rem 0;
            overflow-x: auto;
        }

        .answers {
            display: grid;
            gap: 0.8rem;
            margin: 1.5rem 0;
        }

        .answer {
            display: flex;
            align-items: center;
            padding: 1rem;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .answer:hover {
            border-color: #3498db;
            background: #f8f9ff;
        }

        .answer.selected {
            border-color: #3498db;
            background: #e3f2fd;
        }

        .answer.correct {
            border-color: #27ae60;
            background: #d5f5d5;
            color: #155724;
        }

        .answer.incorrect {
            border-color: #e74c3c;
            background: #f8d7da;
            color: #721c24;
        }

        .answer input[type="radio"] {
            margin-right: 12px;
            transform: scale(1.2);
        }

        .feedback {
            margin: 1rem 0;
            padding: 1rem;
            border-radius: 6px;
            display: none;
        }

        .feedback.show {
            display: block;
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .feedback.correct {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .feedback.incorrect {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .buttons {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #219a52;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .progress-bar {
            background: #ecf0f1;
            height: 8px;
            border-radius: 4px;
            margin-bottom: 2rem;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(90deg, #3498db, #2ecc71);
            height: 100%;
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .results {
            text-align: center;
            padding: 2rem;
            display: none;
        }

        .results.show {
            display: block;
            animation: slideIn 0.5s ease-in-out;
        }

        .score-display {
            font-size: 3rem;
            font-weight: bold;
            color: #2c3e50;
            margin: 1rem 0;
        }

        .score-message {
            font-size: 1.2rem;
            margin-bottom: 2rem;
        }

        .score-excellent { color: #27ae60; }
        .score-good { color: #f39c12; }
        .score-needs-improvement { color: #e74c3c; }

        @media (max-width: 600px) {
            .header h1 { font-size: 2rem; }
            .quiz-container { padding: 1rem; }
            .buttons { flex-direction: column; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Java 21 OCP Practice Quiz</h1>
            <p>Test your knowledge of Java 21 features and OCP exam concepts</p>
        </div>

        <div class="quiz-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <!-- Questions will be dynamically inserted here -->
            <div id="questionsContainer"></div>

            <div class="results" id="results">
                <h2>Quiz Complete!</h2>
                <div class="score-display" id="finalScore"></div>
                <div class="score-message" id="scoreMessage"></div>
                <button class="btn btn-primary" onclick="restartQuiz()">Take Quiz Again</button>
            </div>
        </div>
    </div>

    <script>
        const quizData = [
            {
                question: "What is the READ-WRITE rule for bounded wildcards in Java generics?",
                code: `List<? extends Number> readList = List.of(1, 2.0, 3L);
List<? super Integer> writeList = new ArrayList<Number>();`,
                options: [
                    "Read Extends, Write Super - ? extends allows reading as supertype, ? super allows writing subtypes",
                    "Read Super, Write Extends - ? super allows reading as supertype, ? extends allows writing subtypes", 
                    "Both ? extends and ? super allow both reading and writing with no restrictions",
                    "Read Extends, Write Extends - both wildcards only allow reading operations"
                ],
                correct: 0,
                explanation: "The READ-WRITE rule states: Read Extends, Write Super. ? extends T allows reading items as type T but prevents writing (except null). ? super T allows writing T and its subtypes but only allows reading as Object."
            },
            {
                question: "How do Deque stack and queue operations work together?",
                code: `Deque<String> deque = new ArrayDeque<>();
deque.push("First");        // [First] (head)
deque.offerLast("Last");    // [First, Last] (tail)
deque.push("New First");    // [New First, First, Last] (head)
System.out.println(deque.poll()); // What does this print?`,
                options: [
                    "\"New First\" - poll() removes from head where push() adds",
                    "\"Last\" - poll() removes from tail where offerLast() adds",
                    "\"First\" - poll() removes the middle element",
                    "Throws an exception because you cannot mix stack and queue operations"
                ],
                correct: 0,
                explanation: "Deque can act as both Stack (LIFO) and Queue (FIFO). Stack operations (push/pop) work on the head, Queue operations (offer/poll) work on head for removal and tail for addition. poll() removes from head, so it returns \"New First\"."
            },
            {
                question: "What are the key differences between HashSet, LinkedHashSet, and TreeSet?",
                code: `Set<String> hashSet = new HashSet<>();
Set<String> linkedSet = new LinkedHashSet<>(); 
Set<String> treeSet = new TreeSet<>();`,
                options: [
                    "HashSet: no ordering, O(1); LinkedHashSet: insertion order, O(1); TreeSet: sorted order, O(log n)",
                    "HashSet: sorted order, O(1); LinkedHashSet: no ordering, O(log n); TreeSet: insertion order, O(1)",
                    "All three maintain insertion order and have O(1) operations",
                    "HashSet: insertion order, O(log n); LinkedHashSet: sorted order, O(1); TreeSet: no ordering, O(1)"
                ],
                correct: 0,
                explanation: "HashSet provides no ordering with O(1) operations and allows null. LinkedHashSet maintains insertion order with O(1) operations and allows null. TreeSet maintains natural/comparator ordering with O(log n) operations and does not allow null."
            },
            {
                question: "How does Map.merge() work when the key exists vs doesn't exist?",
                code: `Map<String, Integer> map = new HashMap<>();
map.put("Alice", 85);
map.merge("Alice", 10, Integer::sum);
map.merge("Bob", 88, Integer::sum);
System.out.println(map);`,
                options: [
                    "{Alice=95, Bob=88} - merge function called for existing key, new value inserted for non-existing key",
                    "{Alice=10, Bob=88} - merge function replaces existing values, inserts new values", 
                    "{Alice=85, Bob=88} - merge function is ignored for existing keys",
                    "Compilation error - cannot use method references in merge function"
                ],
                correct: 0,
                explanation: "Map.merge() combines the existing value with the new value using the merge function when the key exists (85 + 10 = 95). When the key doesn't exist, it simply inserts the new value without calling the merge function."
            },
            {
                question: "Can enum constructors be called directly with the new keyword?",
                code: `public enum Planet {
    EARTH(5.976e+24, 6.37814e6),
    MARS(6.421e+23, 3.3972e6);
    
    private final double mass;
    Planet(double mass, double radius) {
        this.mass = mass;
    }
}
// Planet p = new Planet(1.0, 2.0);`,
                options: [
                    "No - enum constructors are implicitly private and can only be called when declaring enum constants",
                    "Yes - enum constructors are public by default and can be called anywhere",
                    "Yes - but only from within the same package as the enum",
                    "No - enum constructors don't exist, values are created using static factory methods"
                ],
                correct: 0,
                explanation: "Enum constructors are implicitly private and cannot be called directly with the new keyword. They can only be called when declaring enum constants. The enum constants are the only instances that can ever exist."
            },
            {
                question: "What does Files.mismatch() return when comparing two files?",
                code: `Path file1 = Path.of("doc1.txt");  // Content: "Hello World"
Path file2 = Path.of("doc2.txt");  // Content: "Hello Mars"
long result = Files.mismatch(file1, file2);`,
                options: [
                    "6 - the index of the first mismatching byte (0-based)",
                    "-1 - indicates files are different",
                    "5 - the number of matching characters before difference", 
                    "Throws IOException because files have different content"
                ],
                correct: 0,
                explanation: "Files.mismatch() returns the index of the first mismatching byte (0-based). In this case, 'W' vs 'M' occurs at index 6. It returns -1 only when files are identical, and throws IOException if paths are invalid."
            },
            {
                question: "What happens if you chain multiple intermediate operations without a terminal operation?",
                code: `Stream<String> pipeline = Stream.of("a", "bb", "ccc")
    .filter(s -> {
        System.out.println("Filtering: " + s);
        return s.length() > 1;
    })
    .map(String::toUpperCase);

System.out.println("Pipeline created");`,
                options: [
                    "Nothing executes - intermediate operations are lazy until a terminal operation is called",
                    "All operations execute immediately when the pipeline is built",
                    "Only the filter operation executes, map waits for terminal operation",
                    "Compilation error - you must have a terminal operation in the same statement"
                ],
                correct: 0,
                explanation: "Intermediate operations are lazy and don't execute until a terminal operation triggers evaluation. Only 'Pipeline created' will print. The filtering won't print until you add a terminal operation like collect() or forEach()."
            },
            {
                question: "What's the difference between Collectors.partitioningBy() and groupingBy()?",
                code: `List<String> words = List.of("a", "bb", "ccc", "dddd");
Map<?, List<String>> result1 = words.stream()
    .collect(Collectors.partitioningBy(w -> w.length() > 2));
Map<?, List<String>> result2 = words.stream()
    .collect(Collectors.groupingBy(String::length));`,
                options: [
                    "partitioningBy creates exactly 2 groups (Boolean keys), groupingBy creates multiple groups based on classifier",
                    "partitioningBy creates multiple groups, groupingBy creates exactly 2 groups",
                    "Both create the same number of groups, only the key types differ",
                    "partitioningBy is for primitive streams, groupingBy is for object streams"
                ],
                correct: 0,
                explanation: "partitioningBy() always creates exactly 2 groups based on a boolean predicate (true/false keys). groupingBy() creates multiple groups based on the classifier function return values."
            },
            {
                question: "Why are LocalDate/LocalTime objects immutable and how does this affect method calls?",
                code: `LocalDate today = LocalDate.now();
today.plusDays(1);
System.out.println(today);  // What prints?`,
                options: [
                    "Today's date - the original object is unchanged because LocalDate is immutable",
                    "Tomorrow's date - plusDays() modifies the original object",
                    "Compilation error - cannot call plusDays() on immutable objects",
                    "Runtime exception - immutable objects throw exceptions when modified"
                ],
                correct: 0,
                explanation: "LocalDate objects are immutable. All methods return new instances - the original object never changes. You must assign the result: LocalDate tomorrow = today.plusDays(1);"
            },
            {
                question: "In try-with-resources, which exception takes priority when both try block and close() throw exceptions?",
                code: `try (MyResource res = new MyResource()) {
    throw new RuntimeException("Primary");
    // close() throws RuntimeException("Close")
} catch (Exception e) {
    // What is e.getMessage()?
}`,
                options: [
                    "\"Primary\" - try block exception is primary, close() exceptions are suppressed",
                    "\"Close\" - close() exceptions take priority over try block exceptions", 
                    "Both exceptions are thrown simultaneously causing compilation error",
                    "The first exception chronologically becomes primary"
                ],
                correct: 0,
                explanation: "The try block exception is primary. Exceptions from close() are suppressed and attached to the primary exception. You can access suppressed exceptions with getSuppressed()."
            },
            {
                question: "How do guarded patterns work in switch expressions?",
                code: `Object obj = "Hello World";
return switch (obj) {
    case String s when s.length() > 5 -> "Long string";
    case String s when s.isEmpty() -> "Empty string";  
    case String s -> "Short string: " + s;
    default -> "Not a string";
};`,
                options: [
                    "\"Long string\" - patterns are checked in order until one matches",
                    "\"Short string: Hello World\" - the most general pattern always wins",
                    "Compilation error - cannot have multiple case labels for the same type",
                    "\"Empty string\" - the when clause reverses the matching order"
                ],
                correct: 0,
                explanation: "Guarded patterns use 'when' to add conditions and are checked in order until one matches. \"Hello World\" has length > 5, so the first case matches and returns \"Long string\"."
            },
            {
                question: "What are the key rules for sealed classes?",
                code: `public sealed class Shape permits Circle, Rectangle, Triangle {}
final class Circle extends Shape {}
sealed class Rectangle extends Shape permits Square {}
non-sealed class Triangle extends Shape {}`,
                options: [
                    "Permitted subclasses must be final, sealed, or non-sealed",
                    "Permitted subclasses can only be final classes",
                    "Sealed classes cannot have any subclasses",
                    "Permitted subclasses are automatically abstract"
                ],
                correct: 0,
                explanation: "Sealed classes restrict inheritance through the permits clause. Permitted subclasses must be: final (cannot be extended), sealed (can only be extended by specific classes), or non-sealed (can be extended by anyone)."
            },
            {
                question: "What do records automatically generate?",
                code: `public record Person(String name, int age) {
    public Person {
        if (age < 0) throw new IllegalArgumentException("Age cannot be negative");
    }
}`,
                options: [
                    "Constructor with all fields, accessor methods (not getters), equals(), hashCode(), toString()",
                    "Only getter methods and toString(), you must write constructor manually",
                    "All methods including setters for mutable fields",
                    "Static factory methods instead of constructors"
                ],
                correct: 0,
                explanation: "Records automatically generate: a constructor with all fields as parameters, accessor methods (just field names, not getXxx), equals(), hashCode(), and toString(). The compact constructor syntax allows validation."
            },
            {
                question: "How does Arrays.binarySearch() indicate when an element is not found?",
                code: `int[] sorted = {10, 20, 30, 40, 50};
int result = Arrays.binarySearch(sorted, 25);
// result = ?`,
                options: [
                    "-3 (negative insertion point minus 1: -(2) - 1)",
                    "-1 (standard not found indicator)",
                    "2 (the insertion point where element should go)",
                    "Throws NoSuchElementException when element not found"
                ],
                correct: 0,
                explanation: "Arrays.binarySearch() returns -(insertion point) - 1 when element not found. For value 25, insertion point is 2 (between 20 and 30), so result is -(2) - 1 = -3."
            },
            {
                question: "What are the wrapper class caching rules?",
                code: `Integer a = 127, b = 127;
Integer c = 128, d = 128;
System.out.println(a == b);  // ?
System.out.println(c == d);  // ?`,
                options: [
                    "true, false - Integer caches -128 to 127, larger values create new objects",
                    "false, false - wrapper classes never use same object references", 
                    "true, true - all wrapper classes always cache their values",
                    "false, true - caching works opposite to the range"
                ],
                correct: 0,
                explanation: "Integer caches values from -128 to 127. Within this range, == returns true (same object reference). Outside this range, new objects are created, so == returns false. Always use .equals() for wrapper comparisons."
            },
            {
                question: "What's the difference between named modules, automatic modules, and the unnamed module?",
                code: `// module-info.java
module com.myapp {
    requires jackson.core;  // What type of module is jackson.core?
}`,
                options: [
                    "Automatic module - JAR on module path without module-info.java gets automatic name from filename",
                    "Named module - all required modules must have explicit module-info.java",
                    "Unnamed module - modules without requires declarations", 
                    "System module - provided by the JDK runtime"
                ],
                correct: 0,
                explanation: "jackson.core is likely an automatic module - a JAR on the module path without module-info.java. The module name is derived from the JAR filename (jackson-core-2.13.jar â†’ jackson.core)."
            },
            {
                question: "What's the difference between method hiding and method overriding?",
                code: `Parent ref = new Child();
ref.instanceMethod();  // Child's version
ref.staticMethod();    // Which version?
ref.field;             // Which field?`,
                options: [
                    "Parent's static method and field - static methods are hidden (compile-time), fields are always hidden",
                    "Child's static method and field - everything follows runtime polymorphism",
                    "Compilation error - cannot access static methods through instance references",
                    "Child's static method, Parent's field - different rules for methods vs fields"
                ],
                correct: 0,
                explanation: "Instance methods are overridden (runtime resolution). Static methods are hidden (compile-time resolution based on reference type). Fields are always hidden (compile-time resolution)."
            },
            {
                question: "When is super() automatically inserted by the compiler?",
                code: `class Parent {
    Parent(String msg) { }  // No no-arg constructor
}
class Child extends Parent {
    Child() { }  // What happens here?
}`,
                options: [
                    "Compilation error - must explicitly call super(args) because parent has no no-arg constructor",
                    "Compiler automatically inserts super() and creates no-arg constructor in Parent",
                    "Child constructor works fine, super() is optional when parent has parameterized constructor",
                    "Runtime error when Child constructor is called"
                ],
                correct: 0,
                explanation: "The compiler only inserts super() if the superclass has a no-argument constructor. When parent has only parameterized constructors, you must explicitly call super(args)."
            },
            {
                question: "What happens when you try to add null to different Collection types?",
                code: `List<String> list = new ArrayList<>();
list.add(null);              // ?

Set<String> treeSet = new TreeSet<>();
treeSet.add(null);           // ?`,
                options: [
                    "ArrayList allows null, TreeSet throws NullPointerException",
                    "Both allow null values without any issues",
                    "Both throw NullPointerException for null values",
                    "ArrayList throws exception, TreeSet allows null"
                ],
                correct: 0,
                explanation: "ArrayList, LinkedList, HashSet, LinkedHashSet, HashMap, LinkedHashMap allow null. TreeSet and TreeMap throw NullPointerException because they cannot compare null values for ordering."
            },
            {
                question: "What's the difference between findFirst() and findAny() in streams?",
                code: `List<String> words = List.of("apple", "banana", "cherry");
Optional<String> first = words.parallelStream().findFirst();
Optional<String> any = words.parallelStream().findAny();`,
                options: [
                    "findFirst() returns first element in encounter order, findAny() returns any element (optimized for parallel)",
                    "findFirst() and findAny() always return the same element",
                    "findFirst() works only on sequential streams, findAny() only on parallel streams",
                    "findFirst() returns Optional.empty(), findAny() returns the last element"
                ],
                correct: 0,
                explanation: "findFirst() returns the first element in encounter order. findAny() returns any element and is optimized for parallel streams where it can return any element without maintaining order."
            }
        ];

        let currentQuestion = 0;
        let score = 0;
        let answers = [];
        let quizCompleted = false;

        function initializeQuiz() {
            currentQuestion = 0;
            score = 0;
            answers = [];
            quizCompleted = false;
            document.getElementById('results').classList.remove('show');
            renderQuestion();
            updateProgress();
        }

        function renderQuestion() {
            const container = document.getElementById('questionsContainer');
            container.innerHTML = '';
            
            const question = quizData[currentQuestion];
            const questionCard = document.createElement('div');
            questionCard.className = 'question-card active';
            questionCard.innerHTML = `
                <div class="question-header">
                    <span>Question ${currentQuestion + 1} of ${quizData.length}</span>
                    <span>Java 21 OCP</span>
                </div>
                <div class="question-title">${question.question}</div>
                ${question.code ? `<div class="code-block">${question.code}</div>` : ''}
                <div class="answers" id="answers-${currentQuestion}">
                    ${question.options.map((option, index) => `
                        <div class="answer" onclick="selectAnswer(${index})">
                            <input type="radio" name="question-${currentQuestion}" value="${index}" id="option-${index}">
                            <label for="option-${index}">${option}</label>
                        </div>
                    `).join('')}
                </div>
                <div class="feedback" id="feedback-${currentQuestion}"></div>
                <div class="buttons">
                    <button class="btn btn-primary" onclick="submitAnswer()" id="submitBtn">Submit Answer</button>
                    ${currentQuestion > 0 ? '<button class="btn btn-secondary" onclick="previousQuestion()">Previous</button>' : ''}
                    <button class="btn btn-success" onclick="nextQuestion()" id="nextBtn" style="display: none;">
                        ${currentQuestion === quizData.length - 1 ? 'View Results' : 'Next Question'}
                    </button>
                </div>
            `;
            
            container.appendChild(questionCard);
        }

        function selectAnswer(answerIndex) {
            const answers = document.querySelectorAll(`#answers-${currentQuestion} .answer`);
            answers.forEach(answer => answer.classList.remove('selected'));
            answers[answerIndex].classList.add('selected');
            
            const radio = document.getElementById(`option-${answerIndex}`);
            radio.checked = true;
            
            document.getElementById('submitBtn').disabled = false;
        }

        function submitAnswer() {
            const selectedAnswer = document.querySelector(`input[name="question-${currentQuestion}"]:checked`);
            if (!selectedAnswer) return;
            
            const answerIndex = parseInt(selectedAnswer.value);
            const question = quizData[currentQuestion];
            const isCorrect = answerIndex === question.correct;
            
            answers[currentQuestion] = {
                selected: answerIndex,
                correct: isCorrect
            };
            
            if (isCorrect) score++;
            
            // Show feedback
            const feedback = document.getElementById(`feedback-${currentQuestion}`);
            feedback.className = `feedback show ${isCorrect ? 'correct' : 'incorrect'}`;
            feedback.innerHTML = `
                <strong>${isCorrect ? 'Correct!' : 'Incorrect!'}</strong><br>
                ${question.explanation}
            `;
            
            // Update answer styling
            const answerElements = document.querySelectorAll(`#answers-${currentQuestion} .answer`);
            answerElements.forEach((element, index) => {
                element.onclick = null; // Disable clicking
                if (index === question.correct) {
                    element.classList.add('correct');
                } else if (index === answerIndex && !isCorrect) {
                    element.classList.add('incorrect');
                }
            });
            
            // Show next button, hide submit button
            document.getElementById('submitBtn').style.display = 'none';
            document.getElementById('nextBtn').style.display = 'inline-block';
        }

        function nextQuestion() {
            if (currentQuestion < quizData.length - 1) {
                currentQuestion++;
                renderQuestion();
                updateProgress();
            } else {
                showResults();
            }
        }

        function previousQuestion() {
            if (currentQuestion > 0) {
                currentQuestion--;
                renderQuestion();
                updateProgress();
                
                // If question was already answered, show the result
                if (answers[currentQuestion]) {
                    const question = quizData[currentQuestion];
                    const answer = answers[currentQuestion];
                    
                    // Select the previously chosen answer
                    const radio = document.getElementById(`option-${answer.selected}`);
                    radio.checked = true;
                    selectAnswer(answer.selected);
                    
                    // Auto-submit to show feedback
                    setTimeout(() => submitAnswer(), 100);
                }
            }
        }

        function updateProgress() {
            const progress = ((currentQuestion + 1) / quizData.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
        }

        function showResults() {
            document.querySelector('.quiz-container').style.display = 'none';
            const results = document.getElementById('results');
            results.classList.add('show');
            
            const percentage = Math.round((score / quizData.length) * 100);
            document.getElementById('finalScore').textContent = `${score}/${quizData.length} (${percentage}%)`;
            
            const messageElement = document.getElementById('scoreMessage');
            let message, className;
            
            if (percentage >= 90) {
                message = "Excellent! You're well-prepared for the Java 21 OCP exam!";
                className = "score-excellent";
            } else if (percentage >= 70) {
                message = "Good job! Keep studying and you'll be ready for the OCP exam.";
                className = "score-good";
            } else if (percentage >= 50) {
                message = "Not bad, but you need more practice with Java 21 concepts.";
                className = "score-needs-improvement";
            } else {
                message = "Keep studying! Focus on the fundamentals of Java 21.";
                className = "score-needs-improvement";
            }
            
            messageElement.textContent = message;
            messageElement.className = `score-message ${className}`;
            
            quizCompleted = true;
        }

        function restartQuiz() {
            document.querySelector('.quiz-container').style.display = 'block';
            initializeQuiz();
        }

        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
            if (quizCompleted) return;
            
            if (e.key >= '1' && e.key <= '4') {
                const answerIndex = parseInt(e.key) - 1;
                if (answerIndex < quizData[currentQuestion].options.length) {
                    selectAnswer(answerIndex);
                }
            } else if (e.key === 'Enter') {
                const submitBtn = document.getElementById('submitBtn');
                const nextBtn = document.getElementById('nextBtn');
                
                if (submitBtn && submitBtn.style.display !== 'none') {
                    submitAnswer();
                } else if (nextBtn && nextBtn.style.display !== 'none') {
                    nextQuestion();
                }
            } else if (e.key === 'ArrowLeft') {
                previousQuestion();
            } else if (e.key === 'ArrowRight') {
                const nextBtn = document.getElementById('nextBtn');
                if (nextBtn && nextBtn.style.display !== 'none') {
                    nextQuestion();
                }
            }
        });

        // Initialize quiz on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeQuiz();
        });

        // Prevent accidental page refresh
        window.addEventListener('beforeunload', function(e) {
            if (!quizCompleted && answers.length > 0) {
                e.preventDefault();
                e.returnValue = '';
                return 'You have unsaved progress. Are you sure you want to leave?';
            }
        });
    </script>
</body>
</html>